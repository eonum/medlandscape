{"ast":null,"code":"import _classCallCheck from \"/Users/moriarty/Documents/UniBe/PSE/medlandscape/medlandscape-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/moriarty/Documents/UniBe/PSE/medlandscape/medlandscape-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/moriarty/Documents/UniBe/PSE/medlandscape/medlandscape-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/moriarty/Documents/UniBe/PSE/medlandscape/medlandscape-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/moriarty/Documents/UniBe/PSE/medlandscape/medlandscape-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nvar _jsxFileName = \"/Users/moriarty/Documents/UniBe/PSE/medlandscape/medlandscape-app/src/components/Maps/CantonMap.js\";\nimport React, { Component } from \"react\";\nimport { GeoJSON, Popup, LayerGroup, Tooltip } from 'react-leaflet';\nimport cantons from './cantons/cantons.json';\nimport Legend from './Legend.js';\nimport { withTranslation } from 'react-i18next';\n\nvar CantonMap =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(CantonMap, _Component);\n\n  function CantonMap(props) {\n    var _this;\n\n    _classCallCheck(this, CantonMap);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CantonMap).call(this, props));\n\n    _this.getCantonStyle = function (item) {\n      var value = _this.props.returnData(item);\n\n      var color = _this.returnColor(value);\n\n      var cantonStyle = {\n        \"dashArray\": 3,\n        // makes outline of cantons appear dashed (higher value = more distance between dashes)\n        \"color\": \"rgb(\" + color + \")\",\n        // outline color\n        \"fillColor\": \"rgb(\" + color + \")\",\n        \"weight\": 3,\n        // defining how big the outline of canton is\n        \"opacity\": 0.6,\n        // outline opacity\n        \"fillOpacity\": 0.8\n      };\n      return cantonStyle;\n    };\n\n    _this.returnColor = function (value) {\n      var classColors = _this.returnColorClasses()[_this.state.colorScheme];\n\n      var boundaries = _this.returnBoundaries();\n\n      for (var i = 0; i < classColors.length && i < boundaries.length; i++) {\n        var upperBoundary = boundaries[i].upper;\n        var lowerBoundary = boundaries[i].lower;\n\n        if (i === 0 && value <= upperBoundary) {\n          // check for values below rounded lower boundary\n          return classColors[0];\n        }\n\n        if (value <= upperBoundary && value > lowerBoundary) return classColors[i];\n        if (i === classColors.length - 1 && value > upperBoundary) //check for values above rounded upper boundary\n          return classColors[classColors.length - 1];\n      }\n    };\n\n    _this.returnRoundFactor = function (boundary, classSize) {\n      var maxRoundingFactor = 1,\n          y = 100000000000000000;\n\n      while (y > 1) {\n        // doesnt let maxRoundingFactor become less than 1 (-> wouldn't work correctly with math.round)\n        if (classSize > y) {\n          maxRoundingFactor = y / 10;\n          break;\n        }\n\n        y /= 10;\n      }\n\n      return maxRoundingFactor;\n    };\n\n    _this.returnBoundaries = function () {\n      var min = _this.props.maxAndMin.min;\n      var max = _this.props.maxAndMin.max;\n\n      var numberOfClasses = _this.returnColorClasses()[_this.state.colorScheme].length;\n\n      var range = max - min;\n      var classSize = range / numberOfClasses; // defining boundaries\n\n      var boundaries = [];\n\n      for (var i = 0; i < numberOfClasses; i++) {\n        var upperBoundary = max - classSize * i;\n        var lowerBoundary = max - classSize * (i + 1);\n\n        var uBroundFactor = _this.returnRoundFactor(upperBoundary, classSize);\n\n        var lBroundFactor = _this.returnRoundFactor(upperBoundary, classSize); //different rounding for small class sizes\n\n\n        if (classSize < 5) {\n          upperBoundary = upperBoundary.toFixed(1);\n          lowerBoundary = lowerBoundary.toFixed(1);\n        } else {\n          upperBoundary = Math.round(upperBoundary / uBroundFactor) * uBroundFactor;\n          lowerBoundary = Math.round(lowerBoundary / lBroundFactor) * lBroundFactor;\n        } // put boundaries into array the right way (unshift adds to the front of array)\n\n\n        boundaries.unshift({\n          upper: upperBoundary,\n          lower: lowerBoundary\n        });\n      }\n\n      return boundaries;\n    };\n\n    _this.returnColorClasses = function () {\n      //const greenToRed8Classes = [\"85, 181, 22\", \"135, 200, 54\", \"177, 213, 15\", \"232, 234, 29\", \"234, 224, 2\", \"245, 175, 1\", \"239, 118, 14\", \"255, 50, 12\"];\n      //const redToGreen8Classes = greenToRed8Classes.slice().reverse();\n      var blue8Classes = [\"235, 240, 255\", \"186, 210, 235\", \"142, 190, 218\", \"90, 158, 204\", \"53, 126, 185\", \"28, 91, 166\", \"11, 50, 129\", \"51, 50, 120\"];\n      var red8Classes = [\"253, 238, 186\", \"249, 227, 151\", \"248 ,  199 ,  122\", \"244,  174,  90\", \"246,  133,  82\", \"235 ,  93,  80\", \"204,  73,  80\", \"165,  50,  50\"];\n      var red5Classes = [\"250, 215, 33\", \"255, 177, 28\", \"255, 115, 19\", \"171, 28, 0\", \"140, 0, 0\"];\n      var colorClassesArray = [blue8Classes, red8Classes];\n      return colorClassesArray;\n    };\n\n    _this.onMouseOver = function (e) {\n      e.target.setStyle({\n        color: \"#000\",\n        opacity: 1\n      });\n      e.target.bringToFront();\n    };\n\n    _this.onMouseOut = function (item, e) {\n      if (!e.target.isPopupOpen()) _this.resetStyle(item, e);\n    };\n\n    _this.resetStyle = function (item, e) {\n      var style = _this.getCantonStyle(item);\n\n      e.target.setStyle(style);\n    };\n\n    _this.state = {\n      colorScheme: ''\n    };\n    return _this;\n  }\n  /**\n   * Definines color of each canton\n   * @param  {Canton Object} item (The canton to style)\n   * @return {Object} style of the canton.\n  */\n\n\n  _createClass(CantonMap, [{\n    key: \"componentWillMount\",\n\n    /**\n    * Sets state for color scheme\n    * color schemes can be mapped to variables in future (with componentWillReceiveProps())\n    */\n    value: function componentWillMount() {\n      var colorClassesArray = this.returnColorClasses();\n      var random = Math.floor(Math.random() * colorClassesArray.length);\n      this.setState({\n        colorScheme: random\n      });\n    }\n    /**\n    \t* Defines canton color classes\n    * If you add or remove colors in the returned array, the Legend.js will adapt dynamically\n    \t* @return {2D Array} color classes arrays consistiing of rgb colors as strings.\n     \t*/\n\n  }, {\n    key: \"render\",\n\n    /**\n     * Draws cantons on the map\n     * Adds popup an tooltip with canton information to each geoJSON\n     * @return {JSX}\n     */\n    value: function render() {\n      var _this2 = this;\n\n      return React.createElement(LayerGroup, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 175\n        },\n        __self: this\n      }, this.props.data.map(function (item) {\n        return React.createElement(GeoJSON, {\n          key: _this2.props.data.indexOf(item),\n          data: cantons[item.name],\n          style: _this2.getCantonStyle(item),\n          onMouseOver: _this2.onMouseOver.bind(_this2),\n          onMouseOut: _this2.onMouseOut.bind(_this2, item),\n          onPopupClose: _this2.resetStyle.bind(_this2, item),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 178\n          },\n          __self: this\n        }, React.createElement(Tooltip, {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 186\n          },\n          __self: this\n        }, item.text + \" (\" + item.name + \")\"), React.createElement(Popup, {\n          maxWidth: \"250\",\n          closeButton: false,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 189\n          },\n          __self: this\n        }, React.createElement(\"table\", {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 193\n          },\n          __self: this\n        }, React.createElement(\"tr\", {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 194\n          },\n          __self: this\n        }, React.createElement(\"td\", {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 195\n          },\n          __self: this\n        }, _this2.props.t(\"popup.canton\")), React.createElement(\"td\", {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 196\n          },\n          __self: this\n        }, item.text, \" (\", item.name, \")\")), React.createElement(\"tr\", {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 198\n          },\n          __self: this\n        }, React.createElement(\"td\", {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 199\n          },\n          __self: this\n        }, _this2.props.variableInfo.text, \":\"), React.createElement(\"td\", {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 200\n          },\n          __self: this\n        }, _this2.props.returnData(item))))));\n      }), React.createElement(Legend, {\n        maxAndMin: this.props.maxAndMin,\n        classColors: this.returnColorClasses()[this.state.colorScheme],\n        boundaries: this.returnBoundaries(),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 207\n        },\n        __self: this\n      }));\n    }\n  }]);\n\n  return CantonMap;\n}(Component);\n\nvar LocalizedCantonMap = withTranslation()(CantonMap);\nexport default LocalizedCantonMap;","map":{"version":3,"sources":["/Users/moriarty/Documents/UniBe/PSE/medlandscape/medlandscape-app/src/components/Maps/CantonMap.js"],"names":["React","Component","GeoJSON","Popup","LayerGroup","Tooltip","cantons","Legend","withTranslation","CantonMap","props","getCantonStyle","item","value","returnData","color","returnColor","cantonStyle","classColors","returnColorClasses","state","colorScheme","boundaries","returnBoundaries","i","length","upperBoundary","upper","lowerBoundary","lower","returnRoundFactor","boundary","classSize","maxRoundingFactor","y","min","maxAndMin","max","numberOfClasses","range","uBroundFactor","lBroundFactor","toFixed","Math","round","unshift","blue8Classes","red8Classes","red5Classes","colorClassesArray","onMouseOver","e","target","setStyle","opacity","bringToFront","onMouseOut","isPopupOpen","resetStyle","style","random","floor","setState","data","map","indexOf","name","bind","text","t","variableInfo","LocalizedCantonMap"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport { GeoJSON, Popup, LayerGroup, Tooltip } from 'react-leaflet'\nimport cantons from './cantons/cantons.json';\nimport Legend from './Legend.js'\nimport { withTranslation } from 'react-i18next';\n\nclass CantonMap extends Component {\n\n\tconstructor(props){\n\t\tsuper(props);\n\t\tthis.state = {\n\t\t\tcolorScheme: ''\n\t\t};\n\t}\n\n  /**\n   * Definines color of each canton\n   * @param  {Canton Object} item (The canton to style)\n   * @return {Object} style of the canton.\n  */\n\tgetCantonStyle = (item) => {\n\t\tconst value = this.props.returnData(item);\n\t\tconst color = this.returnColor(value);\n\t\tconst cantonStyle = {\n\t\t\t\"dashArray\": 3, // makes outline of cantons appear dashed (higher value = more distance between dashes)\n\t\t\t\"color\": \"rgb(\"+color+\")\", // outline color\n    \t\t\"fillColor\": \"rgb(\"+color+\")\",\n    \t\t\"weight\": 3,  // defining how big the outline of canton is\n    \t\t\"opacity\": 0.6, // outline opacity\n    \t\t\"fillOpacity\": 0.8\n\t\t\t};\n\t\treturn cantonStyle;\n\t}\n\n\t/**\n\t * Assigns a color to a given value\n\t * @param  {Number} value of a variable)\n\t * @return {String} rgb color as string.\n \t*/\n\treturnColor = (value) => {\n\t\tconst classColors = this.returnColorClasses()[this.state.colorScheme];\n\t\tconst boundaries = this.returnBoundaries();\n\t\tfor (let i = 0; i < classColors.length && i < boundaries.length; i++){\n\t\t\tconst upperBoundary = boundaries[i].upper;\n\t\t\tconst lowerBoundary = boundaries[i].lower;\n\t\t\tif (i === 0 && value <= upperBoundary){ // check for values below rounded lower boundary\n\t\t\t\treturn classColors[0];}\n\t\t\tif (value <= upperBoundary && value > lowerBoundary)\n\t\t\t\treturn classColors[i];\n\t\t\tif (i === classColors.length -1 && value > upperBoundary) //check for values above rounded upper boundary\n\t\t\t\treturn classColors[classColors.length-1];\n\t\t}\n\t}\n\n\t/**\n\t * calculates rounding factor, used to round boundaries to a nice looking number\n\t * @param  {Number} boundary that has to be rounded\n\t * @param  {Number} classSize coming with the boundary\n\t * @return {Number} maxRoundingFactor biggest rounding factor that can be used for the given boundary.\n \t*/\n\treturnRoundFactor = (boundary, classSize) => {\n\tlet maxRoundingFactor = 1, y = 100000000000000000;\n\twhile (y > 1){ // doesnt let maxRoundingFactor become less than 1 (-> wouldn't work correctly with math.round)\n\t\tif (classSize > y){\n\t\t\tmaxRoundingFactor = y/10;\n\t\t\tbreak;\n\t\t}\n\t\ty/=10\n\t}\n\treturn maxRoundingFactor;\n\t}\n\n\t/**\n\t * Calculates nice rounded boundaries for the color classes\n\t * @param  {Number} value of a variable)\n\t * @return {String} rgb color as string.\n\t*/\n\treturnBoundaries = () => {\n\t\tconst min = this.props.maxAndMin.min;\n\t\tconst max = this.props.maxAndMin.max;\n\t\tconst numberOfClasses = this.returnColorClasses()[this.state.colorScheme].length;\n\t\tconst range = max - min;\n\t\tconst classSize = range / numberOfClasses;\n\t\t// defining boundaries\n\t\tlet boundaries = [];\n\t\tfor (let i = 0; i < numberOfClasses; i++){\n\t\t\tlet upperBoundary = max - classSize * i;\n\t\t\tlet lowerBoundary = max - classSize * (i + 1);\n\t\t\tconst uBroundFactor = this.returnRoundFactor(upperBoundary, classSize);\n\t\t\tconst lBroundFactor = this.returnRoundFactor(upperBoundary, classSize);\n\t\t\t//different rounding for small class sizes\n\t\t\tif (classSize < 5){\n\t\t\t\tupperBoundary = upperBoundary.toFixed(1);\n\t\t\t\tlowerBoundary = lowerBoundary.toFixed(1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tupperBoundary = Math.round((upperBoundary) / uBroundFactor) * uBroundFactor;\n\t\t\t\tlowerBoundary = Math.round((lowerBoundary) / lBroundFactor) * lBroundFactor;\n\t\t\t}\n\t\t\t// put boundaries into array the right way (unshift adds to the front of array)\n\t\t\tboundaries.unshift({\n\t\t\t\tupper: upperBoundary,\n\t\t\t\tlower: lowerBoundary\n\t\t\t})\n\t\t}\n\t\treturn boundaries;\n\t}\n\n\t/**\n\t* Sets state for color scheme\n\t* color schemes can be mapped to variables in future (with componentWillReceiveProps())\n\t*/\n\tcomponentWillMount(){\n\t\tconst colorClassesArray = this.returnColorClasses();\n\t\tconst random = Math.floor((Math.random() * colorClassesArray.length));\n\t\tthis.setState({\n\t\t\tcolorScheme: random,\n\t\t});\n\t}\n\n\t/**\n \t* Defines canton color classes\n\t* If you add or remove colors in the returned array, the Legend.js will adapt dynamically\n \t* @return {2D Array} color classes arrays consistiing of rgb colors as strings.\n  \t*/\n\treturnColorClasses = () => {\n        //const greenToRed8Classes = [\"85, 181, 22\", \"135, 200, 54\", \"177, 213, 15\", \"232, 234, 29\", \"234, 224, 2\", \"245, 175, 1\", \"239, 118, 14\", \"255, 50, 12\"];\n\t\t//const redToGreen8Classes = greenToRed8Classes.slice().reverse();\n\t\tconst blue8Classes = [\"235, 240, 255\", \"186, 210, 235\", \"142, 190, 218\", \"90, 158, 204\", \"53, 126, 185\", \"28, 91, 166\", \"11, 50, 129\", \"51, 50, 120\"];\n\t\tconst red8Classes = [\"253, 238, 186\", \"249, 227, 151\", \"248 ,  199 ,  122\", \"244,  174,  90\", \"246,  133,  82\" , \"235 ,  93,  80\", \"204,  73,  80\",  \"165,  50,  50\"]\n\t\tconst red5Classes = [\"250, 215, 33\", \"255, 177, 28\", \"255, 115, 19\", \"171, 28, 0\", \"140, 0, 0\"];\n\t\tconst colorClassesArray = [blue8Classes, red8Classes];\n\t\treturn colorClassesArray;\n\t}\n\n\t/**\n\t* Changes canton style if you hover on a canton with your mouse\n\t* @param {Object} e the event\n\t*/\n\tonMouseOver = (e) => {\n\t\te.target.setStyle({\n\t\t\tcolor: \"#000\",\n\t\t\topacity: 1\n\t\t});\n\t\te.target.bringToFront();\n\t}\n\n\t/**\n\t* Set back canton style if you hover off a canton with your mouse\n\t* @param {Object} item = the canton you are hovering off\n\t* @param {Object} e the event\n\t*/\n\tonMouseOut = (item, e) => {\n\t\tif (!e.target.isPopupOpen())\n\t\tthis.resetStyle(item, e);\n\t}\n\n\t/**\n\t* Set back canton style\n\t* @param {Object} item = the canton\n\t* @param {Object} e the event\n\t*/\n\tresetStyle = (item, e) => {\n\t\tconst style = this.getCantonStyle(item);\n\t\te.target.setStyle(style);\n\t}\n\n\t/**\n\t * Draws cantons on the map\n\t * Adds popup an tooltip with canton information to each geoJSON\n\t * @return {JSX}\n\t */\n    render() {\n\t\treturn (\n\t\t\t\t<LayerGroup>\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.props.data.map((item) => (\n\t\t\t\t\t\t\t<GeoJSON\n\t\t\t\t\t\t\t\tkey = {this.props.data.indexOf(item)}\n\t\t\t\t\t\t\t\tdata = {cantons[item.name]}\n\t\t\t\t\t\t\t\tstyle = {this.getCantonStyle(item)}\n\t\t\t\t\t\t\t\tonMouseOver = {this.onMouseOver.bind(this)}\n\t\t\t\t\t\t\t\tonMouseOut = {this.onMouseOut.bind(this, item)}\n\t\t\t\t\t\t\t\tonPopupClose = {this.resetStyle.bind(this, item)}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<Tooltip>\n\t\t\t\t\t\t\t\t\t{item.text + \" (\" + item.name + \")\"}\n\t\t\t\t\t\t\t\t</Tooltip>\n\t\t\t\t\t\t\t\t<Popup\n\t\t\t\t\t\t\t\t\tmaxWidth = \"250\"\n\t\t\t\t\t\t\t\t\tcloseButton = {false}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<table>\n\t\t\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t\t\t<td>{this.props.t(\"popup.canton\")}</td>\n\t\t\t\t\t\t\t\t\t\t\t<td>{item.text} ({item.name})</td>\n\t\t\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t\t\t\t<td>{this.props.variableInfo.text}:</td>\n\t\t\t\t\t\t\t\t\t\t\t<td>{this.props.returnData(item)}</td>\n\t\t\t\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t\t\t</table>\n\t\t\t\t\t\t\t\t</Popup>\n\t\t\t\t\t\t\t</GeoJSON>\n\t\t\t\t\t\t))\n\t\t\t\t\t}\n\t\t\t\t\t<Legend maxAndMin={this.props.maxAndMin} classColors={this.returnColorClasses()[this.state.colorScheme]} boundaries={this.returnBoundaries()}/>\n\t\t\t\t</LayerGroup>\n\t\t)\n\t}\n}\n\nconst LocalizedCantonMap = withTranslation()(CantonMap);\nexport default LocalizedCantonMap;\n"]},"metadata":{},"sourceType":"module"}